(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{673:function(e,t,v){"use strict";v.r(t);var _=v(10),a=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"proxy"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#proxy"}},[e._v("#")]),e._v(" Proxy")]),e._v(" "),v("p",[e._v("Proxy 用于修改某些操作的默认行为，等同于在语言层面上做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。")]),e._v(" "),v("p",[e._v("可以理解成在目标对象之前架设一层“"),v("code",[e._v("拦截")]),e._v("”，外界对该对象进行访问时，都必须先通过这层拦截，因此提供一种机制，可以对外界的访问进行过滤和改写。")]),e._v(" "),v("p",[e._v("Proxy可以译为“代理器”")]),e._v(" "),v("h3",{attrs:{id:"声明"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#声明"}},[e._v("#")]),e._v(" 声明")]),e._v(" "),v("div",{staticClass:"language-javascript extra-class"},[v("pre",{pre:!0,attrs:{class:"language-javascript"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" proxy "),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Proxy")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("target"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" handler"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),v("ul",[v("li",[e._v("target: 拦截对象")]),e._v(" "),v("li",[e._v("handler: 参数也是对象，定制拦截行为")])]),e._v(" "),v("h3",{attrs:{id:"方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[e._v("#")]),e._v(" 方法")]),e._v(" "),v("blockquote",[v("p",[e._v("对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。")])]),e._v(" "),v("ol",[v("li",[v("p",[v("code",[e._v("get(target, propKey, receiver)")]),e._v(":拦截对象属性的读取，例如"),v("code",[e._v("proxy.foo")]),e._v("和"),v("code",[e._v("proxy['foo']")])]),e._v(" "),v("ul",[v("li",[e._v("拦截对象不存在的属性，返回"),v("code",[e._v("undefined")])]),e._v(" "),v("li",[e._v("可继承")]),e._v(" "),v("li",[e._v("receiver指向原始的读操作所在的那个对象")]),e._v(" "),v("li",[e._v("如果一个属性不可配置（"),v("code",[e._v("configurable")]),e._v(")且不可写（"),v("code",[e._v("writable")]),e._v("），则不能修改改属性，否则报错")]),e._v(" "),v("li",[e._v("应用场景：函数名链式使用、生成各种DOM")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("set(target, propKey, value, receiver)")]),e._v(":拦截对象属性的设置,例如"),v("code",[e._v("proxy.foo = 1")]),e._v("和"),v("code",[e._v("proxy['foo'] = 1")]),e._v(",返回一个布尔值")]),e._v(" "),v("ul",[v("li",[e._v("receiver指向原始的读操作所在的那个对象")]),e._v(" "),v("li",[e._v("如果拦截对象的某个属性不可写（"),v("code",[e._v("writable")]),e._v("）,那么"),v("code",[e._v("set")]),e._v("方法不起作用")]),e._v(" "),v("li",[e._v("严格模式下不返还"),v("code",[e._v("true")]),e._v("就会报错")]),e._v(" "),v("li",[e._v("应用场景：验证设置的数据、数据绑定、内部属性不被外部使用（_）")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("apply(target, ctx, args)")]),e._v(": 拦截proxy实例作为函数调用的操作，例如"),v("code",[e._v("proxy(...args)")]),e._v("、"),v("code",[e._v("proxy.call(object, ...args)")]),e._v("和"),v("code",[e._v("proxy.apply(...)")]),e._v("操作")]),e._v(" "),v("ul",[v("li",[e._v("call&apply使用时要兼容get")]),e._v(" "),v("li",[e._v("直接调用Reflect.apply方法,也会被拦截"),v("code",[e._v("Reflect.apply(fnProxy, null, [9, 10]) // 38")])])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("construct(target, args, newTarget)")]),e._v(": 拦截proxy实例作为构造函数调用的操作，例如"),v("code",[e._v("new proxy(...args)")])]),e._v(" "),v("ul",[v("li",[e._v("目标对象必须是函数，否则报错")]),e._v(" "),v("li",[e._v("返回的必须是一个对象，否则报错")]),e._v(" "),v("li",[v("code",[e._v("this")]),e._v("指向"),v("code",[e._v("handler")]),e._v(",而不是实例对象")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("has(target, propKey)")]),e._v(":拦截"),v("code",[e._v("hasProperty")]),e._v("操作，例如"),v("code",[e._v("propKey in proxy")]),e._v("和"),v("code",[e._v("Reflect.has(fnProxy, 'count')")]),e._v("，返回一个布尔值")]),e._v(" "),v("ul",[v("li",[e._v("如果原对象不可配置或者禁止拓展，会报错 "),v("code",[e._v("Object.preventExtensions(hasObj)")])]),e._v(" "),v("li",[v("code",[e._v("for...in")]),e._v("不生效")]),e._v(" "),v("li",[e._v("应用场景：隐藏某些属性不被"),v("code",[e._v("in")]),e._v("运算法发现，例如"),v("code",[e._v("_prop")])])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("deleteProperty(target, propKey)")]),e._v(":拦截"),v("code",[e._v("delete proxy[propKey]")]),e._v("操作，返回一个布尔值")]),e._v(" "),v("ul",[v("li",[e._v("抛出异常或者返回"),v("code",[e._v("false")]),e._v(",当前属性不删除")]),e._v(" "),v("li",[e._v("如果原对象不可配置，会报错")]),e._v(" "),v("li",[e._v("应用场景：隐藏某些属性不被delete运算法发现，例如_prop")])])])]),e._v(" "),v("h3",{attrs:{id:"示例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[e._v("#")]),e._v(" 示例")]),e._v(" "),v("p",{staticClass:"codepen",staticStyle:{height:"600px","box-sizing":"border-box",display:"flex","align-items":"center","justify-content":"center",border:"2px solid",margin:"1em 0",padding:"1em"},attrs:{"data-height":"600","data-theme-id":"dark","data-default-tab":"js","data-slug-hash":"QWQgbMg","data-user":"Jun_9527"}},[v("span",[e._v("See the Pen "),v("a",{attrs:{href:"https://codepen.io/Jun_9527/pen/QWQgbMg"}},[e._v("\n  15 Proxy")]),e._v(" by Jun_9527 ("),v("a",{attrs:{href:"https://codepen.io/Jun_9527"}},[e._v("@Jun_9527")]),e._v(")\n  on "),v("a",{attrs:{href:"https://codepen.io"}},[e._v("CodePen")]),e._v(".")])]),e._v(" "),v("script",{attrs:{async:"",src:"https://cpwebassets.codepen.io/assets/embed/ei.js"}}),e._v(" "),v("h3",{attrs:{id:"this问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#this问题"}},[e._v("#")]),e._v(" this问题")]),e._v(" "),v("p",[e._v("虽然Proxy可以代理目标对象的访问，但它不是目标对象的透明代理，即不作任何拦截的情况下，也无法保证与目标对象的行为一致")]),e._v(" "),v("p",[e._v("主要原因是，Proxy代理情况下:")]),e._v(" "),v("ul",[v("li",[e._v("目标对象内部的"),v("code",[e._v("this")]),e._v("关键字会指向Proxy实例")]),e._v(" "),v("li",[e._v("有些原生对象的内部属性，只有通过正确的this才能拿到，所以 Proxy 也无法代理这些原生对象的属性。例如"),v("code",[e._v("const target = new Date()")])]),e._v(" "),v("li",[e._v("拦截函数内部this指向handler")])])])}),[],!1,null,null,null);t.default=a.exports}}]);